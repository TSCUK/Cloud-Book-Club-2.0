-- 0. PROFILES (Sync with Supabase Auth)
-- Create a table for public profiles
create table if not exists profiles (
  id uuid references auth.users on delete cascade not null primary key,
  email text,
  full_name text,
  avatar_url text,
  first_name text,
  last_name text,
  role text default 'member',
  updated_at timestamp with time zone
);

-- Set up Row Level Security (RLS)
alter table profiles enable row level security;

-- Drop existing policies if rebuilding to avoid conflicts
drop policy if exists "Public profiles are viewable by everyone." on profiles;
drop policy if exists "Users can insert their own profile." on profiles;
drop policy if exists "Users can update own profile." on profiles;

create policy "Public profiles are viewable by everyone." on profiles
  for select using (true);

create policy "Users can insert their own profile." on profiles
  for insert with check (auth.uid() = id);

create policy "Users can update own profile." on profiles
  for update using (auth.uid() = id);

-- Function to handle new user signup
create or replace function public.handle_new_user()
returns trigger as $$
begin
  insert into public.profiles (id, email, full_name, avatar_url)
  values (
    new.id, 
    new.email, 
    new.raw_user_meta_data->>'full_name', 
    new.raw_user_meta_data->>'avatar_url'
  );
  return new;
end;
$$ language plpgsql security definer;

-- Trigger to call the function on new user creation
drop trigger if exists on_auth_user_created on auth.users;
create trigger on_auth_user_created
  after insert on auth.users
  for each row execute procedure public.handle_new_user();

-- 1. CLUBS
create table if not exists clubs (
  club_id bigint generated by default as identity primary key,
  name text not null,
  description text,
  privacy text default 'public', -- 'public' or 'private'
  created_by uuid references public.profiles(id),
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  image_url text,
  category text
);

-- 2. BOOKS
create table if not exists books (
  book_id bigint generated by default as identity primary key,
  title text not null,
  author text,
  isbn text,
  language text,
  published_year int,
  cover_image_url text
);

-- 3. CLUB MEMBERS (Linking Users to Clubs)
create table if not exists club_members (
  club_member_id bigint generated by default as identity primary key,
  club_id bigint references clubs(club_id) on delete cascade,
  user_id uuid references public.profiles(id) on delete cascade,
  role text default 'member',
  member_status text default 'active',
  joined_at timestamp with time zone default timezone('utc'::text, now()) not null,
  unique(club_id, user_id)
);

-- 4. CLUB READS (Books assigned to a club)
create table if not exists club_reads (
  club_read_id bigint generated by default as identity primary key,
  club_id bigint references clubs(club_id) on delete cascade,
  book_id bigint references books(book_id) on delete cascade,
  status text default 'planned',
  start_date date,
  end_date date
);

-- 5. READING PROGRESS
create table if not exists reading_progress (
  progress_id bigint generated by default as identity primary key,
  club_read_id bigint references club_reads(club_read_id) on delete cascade,
  user_id uuid references public.profiles(id) on delete cascade,
  progress_type text default 'page',
  progress_value decimal default 0,
  updated_at timestamp with time zone default timezone('utc'::text, now()) not null,
  unique(club_read_id, user_id)
);

-- 6. DISCUSSION THREADS
create table if not exists discussion_threads (
  thread_id bigint generated by default as identity primary key,
  club_id bigint references clubs(club_id) on delete cascade,
  club_read_id bigint references club_reads(club_read_id),
  created_by uuid references public.profiles(id),
  title text not null,
  is_pinned boolean default false,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- 7. THREAD COMMENTS
create table if not exists thread_comments (
  comment_id bigint generated by default as identity primary key,
  thread_id bigint references discussion_threads(thread_id) on delete cascade,
  user_id uuid references public.profiles(id),
  parent_comment_id bigint references thread_comments(comment_id),
  content text not null,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  updated_at timestamp with time zone,
  is_deleted boolean default false
);

-- 8. EVENTS
create table if not exists events (
  event_id bigint generated by default as identity primary key,
  club_id bigint references clubs(club_id) on delete cascade,
  created_by uuid references public.profiles(id),
  title text not null,
  description text,
  location_type text,
  location_details text,
  start_datetime timestamp with time zone,
  end_datetime timestamp with time zone,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- 9. EVENT ATTENDEES
create table if not exists event_attendees (
  event_attendee_id bigint generated by default as identity primary key,
  event_id bigint references events(event_id) on delete cascade,
  user_id uuid references public.profiles(id) on delete cascade,
  rsvp_status text,
  responded_at timestamp with time zone default timezone('utc'::text, now()) not null,
  unique(event_id, user_id)
);

-- --- RLS POLICIES ---

-- CLUBS
alter table clubs enable row level security;
drop policy if exists "Clubs are viewable by everyone" on clubs;
create policy "Clubs are viewable by everyone" on clubs for select using (true);
drop policy if exists "Authenticated users can create clubs" on clubs;
create policy "Authenticated users can create clubs" on clubs for insert with check (auth.role() = 'authenticated');

-- MEMBERS
alter table club_members enable row level security;
drop policy if exists "Members viewable by everyone" on club_members;
create policy "Members viewable by everyone" on club_members for select using (true);
drop policy if exists "Users can join clubs" on club_members;
create policy "Users can join clubs" on club_members for insert with check (auth.uid() = user_id);

-- BOOKS
alter table books enable row level security;
drop policy if exists "Books viewable by everyone" on books;
create policy "Books viewable by everyone" on books for select using (true);
drop policy if exists "Authenticated users can add books" on books;
create policy "Authenticated users can add books" on books for insert with check (auth.role() = 'authenticated');

-- CLUB READS
alter table club_reads enable row level security;
drop policy if exists "Club reads are viewable by everyone" on club_reads;
create policy "Club reads are viewable by everyone" on club_reads for select using (true);
drop policy if exists "Authenticated users can add club reads" on club_reads;
create policy "Authenticated users can add club reads" on club_reads for insert with check (auth.role() = 'authenticated');

-- READING PROGRESS
alter table reading_progress enable row level security;
drop policy if exists "Users can view own progress" on reading_progress;
create policy "Users can view own progress" on reading_progress for select using (auth.uid() = user_id);
drop policy if exists "Users can manage own progress" on reading_progress;
create policy "Users can manage own progress" on reading_progress for all using (auth.uid() = user_id);

-- DISCUSSIONS
alter table discussion_threads enable row level security;
drop policy if exists "Threads are viewable by everyone" on discussion_threads;
create policy "Threads are viewable by everyone" on discussion_threads for select using (true);
drop policy if exists "Authenticated users can create threads" on discussion_threads;
create policy "Authenticated users can create threads" on discussion_threads for insert with check (auth.role() = 'authenticated');

-- COMMENTS
alter table thread_comments enable row level security;
drop policy if exists "Comments are viewable by everyone" on thread_comments;
create policy "Comments are viewable by everyone" on thread_comments for select using (true);
drop policy if exists "Authenticated users can post comments" on thread_comments;
create policy "Authenticated users can post comments" on thread_comments for insert with check (auth.role() = 'authenticated');
