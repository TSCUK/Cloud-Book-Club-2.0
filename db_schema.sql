-- ==========================================
-- CLOUDBOOK CLUB - DATABASE SETUP & REPAIR
-- ==========================================

-- 0. CLEANUP (Optional: Only if you want a fresh start, otherwise keep commented)
-- DROP TABLE IF EXISTS reading_progress CASCADE;
-- DROP TABLE IF EXISTS club_members CASCADE;
-- DROP TABLE IF EXISTS club_reads CASCADE;
-- DROP TABLE IF EXISTS clubs CASCADE;
-- DROP TABLE IF EXISTS profiles CASCADE;

-- 1. PROFILES (Sync with Supabase Auth)
create table if not exists profiles (
  id uuid references auth.users on delete cascade not null primary key,
  email text,
  full_name text,
  avatar_url text,
  first_name text,
  last_name text,
  role text default 'member',
  updated_at timestamp with time zone
);

-- RLS
alter table profiles enable row level security;

-- DROP existing policies to ensure clean state
drop policy if exists "Public profiles are viewable by everyone." on profiles;
drop policy if exists "Users can insert their own profile." on profiles;
drop policy if exists "Users can update own profile." on profiles;
drop policy if exists "Users can delete own profile." on profiles; -- NEW

-- CREATE robust policies
create policy "Public profiles are viewable by everyone." on profiles
  for select using (true);

create policy "Users can insert their own profile." on profiles
  for insert with check (auth.uid() = id);

create policy "Users can update own profile." on profiles
  for update using (auth.uid() = id);

create policy "Users can delete own profile." on profiles
  for delete using (auth.uid() = id); -- NEW

-- 2. TRIGGER to handle new user signup
create or replace function public.handle_new_user()
returns trigger as $$
declare
  default_avatar text;
  user_full_name text;
begin
  user_full_name := coalesce(new.raw_user_meta_data->>'full_name', 'Reader');
  
  -- Generate avatar URL if none provided
  if new.raw_user_meta_data->>'avatar_url' is null or new.raw_user_meta_data->>'avatar_url' = '' then
    default_avatar := 'https://ui-avatars.com/api/?background=c26d53&color=fff&name=' || replace(user_full_name, ' ', '+');
  else
    default_avatar := new.raw_user_meta_data->>'avatar_url';
  end if;

  insert into public.profiles (id, email, full_name, avatar_url)
  values (
    new.id, 
    new.email, 
    user_full_name, 
    default_avatar
  )
  on conflict (id) do update set
    email = excluded.email,
    full_name = excluded.full_name;
    
  return new;
end;
$$ language plpgsql security definer;

-- Re-create trigger
drop trigger if exists on_auth_user_created on auth.users;
create trigger on_auth_user_created
  after insert on auth.users
  for each row execute procedure public.handle_new_user();

-- =========================================================
-- REPAIR SCRIPT: Run this to fix "It was working previously"
-- This inserts profiles for any users that exist in Auth 
-- but are missing from the Profiles table.
-- =========================================================
insert into public.profiles (id, email, full_name, avatar_url)
select 
  id, 
  email, 
  coalesce(raw_user_meta_data->>'full_name', 'Reader'),
  coalesce(
    raw_user_meta_data->>'avatar_url', 
    'https://ui-avatars.com/api/?background=c26d53&color=fff&name=' || replace(coalesce(raw_user_meta_data->>'full_name', 'Reader'), ' ', '+')
  )
from auth.users
where id not in (select id from public.profiles)
on conflict (id) do nothing;


-- 3. CLUBS & OTHER TABLES
create table if not exists clubs (
  club_id bigint generated by default as identity primary key,
  name text not null,
  description text,
  privacy text default 'public', 
  created_by uuid references public.profiles(id),
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  image_url text,
  category text
);

create table if not exists books (
  book_id bigint generated by default as identity primary key,
  title text not null,
  author text,
  isbn text,
  language text,
  published_year int,
  cover_image_url text
);

create table if not exists club_members (
  club_member_id bigint generated by default as identity primary key,
  club_id bigint references clubs(club_id) on delete cascade,
  user_id uuid references public.profiles(id) on delete cascade,
  role text default 'member',
  member_status text default 'active',
  joined_at timestamp with time zone default timezone('utc'::text, now()) not null,
  unique(club_id, user_id)
);

create table if not exists club_reads (
  club_read_id bigint generated by default as identity primary key,
  club_id bigint references clubs(club_id) on delete cascade,
  book_id bigint references books(book_id) on delete cascade,
  status text default 'planned',
  start_date date,
  end_date date
);

create table if not exists reading_progress (
  progress_id bigint generated by default as identity primary key,
  club_read_id bigint references club_reads(club_read_id) on delete cascade,
  user_id uuid references public.profiles(id) on delete cascade,
  progress_type text default 'page',
  progress_value decimal default 0,
  updated_at timestamp with time zone default timezone('utc'::text, now()) not null,
  unique(club_read_id, user_id)
);

create table if not exists discussion_threads (
  thread_id bigint generated by default as identity primary key,
  club_id bigint references clubs(club_id) on delete cascade,
  club_read_id bigint references club_reads(club_read_id),
  created_by uuid references public.profiles(id),
  title text not null,
  is_pinned boolean default false,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

create table if not exists thread_comments (
  comment_id bigint generated by default as identity primary key,
  thread_id bigint references discussion_threads(thread_id) on delete cascade,
  user_id uuid references public.profiles(id),
  parent_comment_id bigint references thread_comments(comment_id),
  content text not null,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  updated_at timestamp with time zone,
  is_deleted boolean default false
);

-- RLS POLICIES FOR APP TABLES
alter table clubs enable row level security;
drop policy if exists "Clubs are viewable by everyone" on clubs;
create policy "Clubs are viewable by everyone" on clubs for select using (true);
drop policy if exists "Authenticated users can create clubs" on clubs;
create policy "Authenticated users can create clubs" on clubs for insert with check (auth.role() = 'authenticated');

alter table club_members enable row level security;
drop policy if exists "Members viewable by everyone" on club_members;
create policy "Members viewable by everyone" on club_members for select using (true);
drop policy if exists "Users can join clubs" on club_members;
create policy "Users can join clubs" on club_members for insert with check (auth.uid() = user_id);

alter table books enable row level security;
drop policy if exists "Books viewable by everyone" on books;
create policy "Books viewable by everyone" on books for select using (true);
drop policy if exists "Authenticated users can add books" on books;
create policy "Authenticated users can add books" on books for insert with check (auth.role() = 'authenticated');

alter table club_reads enable row level security;
drop policy if exists "Club reads are viewable by everyone" on club_reads;
create policy "Club reads are viewable by everyone" on club_reads for select using (true);
drop policy if exists "Authenticated users can add club reads" on club_reads;
create policy "Authenticated users can add club reads" on club_reads for insert with check (auth.role() = 'authenticated');

alter table reading_progress enable row level security;
drop policy if exists "Users can view own progress" on reading_progress;
create policy "Users can view own progress" on reading_progress for select using (auth.uid() = user_id);
drop policy if exists "Users can manage own progress" on reading_progress;
create policy "Users can manage own progress" on reading_progress for all using (auth.uid() = user_id);

alter table discussion_threads enable row level security;
drop policy if exists "Threads are viewable by everyone" on discussion_threads;
create policy "Threads are viewable by everyone" on discussion_threads for select using (true);
drop policy if exists "Authenticated users can create threads" on discussion_threads;
create policy "Authenticated users can create threads" on discussion_threads for insert with check (auth.role() = 'authenticated');

alter table thread_comments enable row level security;
drop policy if exists "Comments are viewable by everyone" on thread_comments;
create policy "Comments are viewable by everyone" on thread_comments for select using (true);
drop policy if exists "Authenticated users can post comments" on thread_comments;
create policy "Authenticated users can post comments" on thread_comments for insert with check (auth.role() = 'authenticated');
